{"version":3,"sources":["utils/spotify.ts","contexts/event.tsx","services/gtm.ts","contexts/user.tsx","mappers/image.ts","mappers/music.ts","utils/timer.ts","utils/player.ts","contexts/player.tsx","components/loader/index.tsx","mappers/search.ts","contexts/search.tsx","contexts/activity.tsx","contexts/feeling.tsx","contexts/location.tsx","services/request.ts","utils/string.ts","serviceWorker.ts","components/router/index.tsx","mappers/playlist.ts","contexts/playlist.tsx","contexts/index.tsx","index.tsx","services/storage.ts","contexts/auth.tsx"],"names":["SpotifyUtil","url","URL","process","searchParams","set","getSpotifyRedirectUrl","this","SCOPES","join","toString","accessToken","Promise","resolve","reject","window","onSpotifyWebPlaybackSDKReady","player","Spotify","Player","name","getOAuthToken","cb","addListener","message","device_id","original","connect","redirectUrl","search","hash","slice","length","get","expiresInSeconds","Number","tokenType","Error","EventType","gtmService","eventName","customProps","tagsWereNotFired","dataLayer","push","event","console","log","ex","apiEndpoint","REACT_APP_API_HOST","eventApiEndpoint","UserContext","createContext","eventsHistory","EventsProvider","props","spotifyUserUri","useUser","profile","uri","type","value","a","data","hasToSaveTheEvent","sendEvent","requestService","post","lastEvent","PAUSE_MUSIC","PLAY_MUSIC","Provider","save","useEvents","useContext","spotifyUserEndpoint","getApiUrl","userApiEndpoint","UserProvider","useAuth","isAuthenticated","useState","setProfile","id","email","display_name","link","external_urls","spotify","images","avatarSrc","tryToSaveAtApi","spotifyUri","endpoint","devices","basicUser","useEffect","load","getAvailableDevices","ImageMapper","alt","src","MusicMapper","album","image","toCustom","TimerUtil","callback","wait","timeout","params","clearTimeout","setTimeout","time","musicHistory","PlayerUtil","state","current_track","track_window","lastMusic","paused","CHANGE_MUSIC","position","RESTART_MUSIC","MusicContext","debounce","saveEvent","stateToEvent","PlayerProvider","setPlayer","isPluginPlayerActive","setIsPluginPlayerActive","isPlayerReady","setIsPlayerReady","playingMusicInfo","setPlayingMusicInfo","createSpotifyPlayerIfNeed","createPlayer","loadCurrentPlayerInfo","getCurrentPlayerInfo","currentPlayer","device","nextTrack","previousTrack","togglePlay","put","device_ids","createSpotifyPlayerIfNeedAndValidatePlayer","duration","currentTrack","toMusicTrack","transferUserPlaybackToPlugin","usePlayer","Loader","className","SearchMapper","track","toMusic","SearchContext","spotifySearchEndpoint","SearchProvider","text","q","artists","items","map","toArtist","tracks","searchArtists","searchMusic","useSearch","USE_API","REACT_APP_USE_API_TO_LOAD_ACTIVITY","baseHost","ActivityContext","ActivityProvider","searchFromApi","searchFromJson","filter","l","toLowerCase","includes","StringUtil","toKebabCase","useActivity","REACT_APP_USE_API_TO_LOAD_FEELINGS","FeelingContext","FeelingProvider","useFeeling","REACT_APP_USE_API_TO_LOAD_LOCATION","LocationContext","LocationProvider","useLocation","RequestService","getRequest","request","parseRequest","axios","response","mapAxiosToResponse","postRequest","method","putRequest","isString","headers","status","SpotifyRequestService","Authorization","any","trim","str","size","normalize","replace","def","Boolean","location","hostname","match","PrivateRoute","children","rest","render","to","pathname","from","NonAuthRoute","PlaylistMapper","description","title","sliceIfNeed","musics","t","PlaylistContext","spotifyPlaylistsEndpoint","spotifyLoadPlaylistEndpoint","PlaylistProvider","playlistId","musicsIds","uris","toBasicPlaylist","toPlaylist","newName","addMusics","create","loadAll","rename","AppProviders","Home","React","lazy","Welcome","Login","LoginRedirectSpotify","Logout","Artists","Gender","Feeling","Activity","Location","MusicSearch","ReactDOM","fallback","path","exact","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","cookieService","key","cookie","start","indexOf","substring","split","decodeURIComponent","expires","date","Date","setTime","getTime","toUTCString","AuthContext","AuthProvider","setAccessToken","setRequestService","setIsAuthenticated","isEmpty","logout","delete","saveToken","getTokenAndInfoFromRedirectUrl","newAccessToken"],"mappings":"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","file":"static/js/main.835406df.chunk.js","sourcesContent":["\r\nexport interface SpotifyToken {\r\n  accessToken: string;\r\n  expiresInSeconds: number;\r\n  tokenType: string;\r\n}\r\n\r\nexport interface SpotifyPlayer {\r\n  device_id: string;\r\n  original: Spotify.SpotifyPlayer;\r\n}\r\n\r\nexport class SpotifyUtil {\r\n  static SCOPES = [\r\n    \"playlist-modify-private\",\r\n    \"playlist-modify-public\",\r\n    \"playlist-read-private\",\r\n    \"streaming\",\r\n    \"user-library-read\",\r\n    \"user-read-email\",\r\n    \"user-read-playback-state\",\r\n    \"user-read-private\",\r\n    \"user-read-recently-played\",\r\n    \"user-top-read\",\r\n  ];\r\n\r\n  static createSpotifyAuthUrl(): string {\r\n    if (!process.env.REACT_APP_SPOTIFY_AUTH_URL) {\r\n      throw new Error(\"you need to set spotify url\");\r\n    }\r\n\r\n    if (!process.env.REACT_APP_SPOTIFY_CLIENT_ID) {\r\n      throw new Error(\"you need to set spotify client id\");\r\n    }\r\n\r\n    var url = new URL(process.env.REACT_APP_SPOTIFY_AUTH_URL);\r\n\r\n    url.searchParams.set(\"client_id\", process.env.REACT_APP_SPOTIFY_CLIENT_ID);\r\n    url.searchParams.set(\"response_type\", \"token\");\r\n    url.searchParams.set(\"redirect_uri\", SpotifyUtil.getSpotifyRedirectUrl());\r\n    url.searchParams.set(\"scope\", this.SCOPES.join(\" \"));\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  static createPlayer(accessToken: string): Promise<SpotifyPlayer> {\r\n    return new Promise((resolve, reject) => {\r\n      window.onSpotifyWebPlaybackSDKReady = () => {\r\n        const player = new Spotify.Player({\r\n          name: 'Spotify plugin',\r\n          getOAuthToken: cb => { cb(accessToken); }\r\n        });\r\n\r\n        // Error handling\r\n        player.addListener('initialization_error', ({ message }) => reject(message));\r\n        player.addListener('authentication_error', ({ message }) => reject(message));\r\n        player.addListener('account_error', ({ message }) => reject(message));\r\n        player.addListener('playback_error', ({ message }) => reject(message));\r\n        player.addListener('not_ready', ({ device_id }) => reject(`Device ID has gone offline ${device_id}`))\r\n\r\n        // Ready\r\n        player.addListener('ready', ({ device_id }) => resolve({ device_id, original: player }));\r\n\r\n        // Connect to the player!\r\n        player.connect();\r\n      };\r\n    })\r\n  }\r\n\r\n  static getApiUrl(): string {\r\n    return process.env.REACT_APP_SPOTIFY_API_URL || \"https://api.spotify.com/v1\";\r\n  }\r\n\r\n  static getTokenAndInfoFromRedirectUrl(redirectUrl: string): SpotifyToken {\r\n    var url = new URL(redirectUrl);\r\n\r\n    url.search = url.hash.slice(2, url.hash.length);\r\n\r\n    const accessToken = url.searchParams.get(\"access_token\");\r\n    const expiresInSeconds = Number(url.searchParams.get(\"expires_in\"));\r\n    const tokenType = url.searchParams.get(\"token_type\");\r\n\r\n    if (!accessToken || !expiresInSeconds || !tokenType) {\r\n      throw new Error(\"Invalid redirect parameter\");\r\n    }\r\n\r\n    return {\r\n      accessToken,\r\n      expiresInSeconds,\r\n      tokenType,\r\n    };\r\n  }\r\n\r\n  private static getSpotifyRedirectUrl(): string {\r\n    if (!process.env.REACT_APP_HOST_URL) {\r\n      throw new Error(\"you need to set spotify client id\");\r\n    }\r\n\r\n    var url = new URL(process.env.REACT_APP_HOST_URL);\r\n\r\n    url.hash = \"/login-redirect-spotify\";\r\n\r\n    return url.toString();\r\n  }\r\n}\r\n","import React, { createContext, useContext } from \"react\";\r\nimport { requestService } from \"../services/request\";\r\nimport { useUser } from \"./user\";\r\nimport { gtmService } from \"../services/gtm\";\r\n\r\ninterface Props {}\r\n\r\nexport enum EventType {\r\n  CHANGE_MUSIC_TIME = \"CHANGE_MUSIC_TIME\",\r\n  CHANGE_MUSIC = \"CHANGE_MUSIC\",\r\n  RESTART_MUSIC = \"RESTART_MUSIC\",\r\n  CHOOSE_ACTIVITY = \"CHOOSE_ACTIVITY\",\r\n  CHOOSE_FEELING = \"CHOOSE_FEELING\",\r\n  CHOOSE_LOCATION = \"CHOOSE_LOCATION\",\r\n  HIDE_DETAILS = \"HIDE_DETAILS\",\r\n  LIKED_ARTIST = \"LIKED_ARTIST\",\r\n  LIKED_GENRE = \"LIKED_GENRE\",\r\n  LIKED_MUSIC = \"LIKED_MUSIC\",\r\n  LOAD_LOCATION = \"LOAD_LOCATION\",\r\n  PAUSE_MUSIC = \"PAUSE_MUSIC\",\r\n  PLAY_MUSIC = \"PLAY_MUSIC\",\r\n  SHOW_DETAILS = \"SHOW_DETAILS\",\r\n}\r\n\r\ninterface Context {\r\n  save: (type: EventType, value?: string) => Promise<void>;\r\n}\r\n\r\nconst apiEndpoint = process.env.REACT_APP_API_HOST || \"https://localhost:44301/api\";\r\nconst eventApiEndpoint = `${apiEndpoint}/UserEvents`;\r\n\r\nconst UserContext = createContext({} as any);\r\nconst useGTM = process.env.REACT_APP_USE_GTM !== \"false\";\r\nconst eventsHistory: EventType[] = [];\r\n\r\nexport function EventsProvider(props: Props) {\r\n  const { profile } = useUser();\r\n  const spotifyUserUri = profile.uri;\r\n\r\n  async function save(type: EventType, value?: string): Promise<void> {\r\n    const data = { type, value, spotifyUserUri };\r\n\r\n    if (hasToSaveTheEvent(type)) {\r\n      if (useGTM) {\r\n        gtmService.sendEvent(\"USER_ACTION\", data);\r\n      } else {\r\n        await requestService.post({ url: eventApiEndpoint, data });\r\n      }\r\n    }\r\n  }\r\n\r\n  function hasToSaveTheEvent(type: EventType) {\r\n    const lastEvent = eventsHistory[eventsHistory.length - 1];\r\n\r\n    eventsHistory.push(type);\r\n\r\n    return !(type === lastEvent && (type === EventType.PAUSE_MUSIC || type === EventType.PLAY_MUSIC));\r\n  }\r\n\r\n  return <UserContext.Provider value={{ save }} {...props} />;\r\n}\r\n\r\nexport const useEvents = () => useContext<Context>(UserContext);\r\n","interface DataLayer {\r\n  event?: string\r\n}\r\n\r\ndeclare const dataLayer: DataLayer[]\r\n\r\nclass GtmService {\r\n  sendEvent(eventName: string, customProps: object = {}): boolean {\r\n    let tagsWereNotFired = false\r\n\r\n    try {\r\n      tagsWereNotFired = !!dataLayer.push({\r\n        event: eventName,\r\n        ...customProps,\r\n      })\r\n\r\n      if (tagsWereNotFired) {\r\n        console.log('There is no gtm tags for the event: ', eventName)\r\n      }\r\n    } catch (ex) {\r\n      console.log('There was a problem to send the gtm event ', ex)\r\n    }\r\n\r\n    return tagsWereNotFired\r\n  }\r\n}\r\n\r\nexport const gtmService = new GtmService()","import React, { createContext, useContext, useState, useEffect } from \"react\";\r\nimport { useAuth } from \"./auth\";\r\n\r\nimport { SpotifyUserGetResponse, SpotifyDevicesResponse, SpotifyDevice } from \"../@types/spotify\";\r\nimport { SpotifyUtil } from \"../utils/spotify\";\r\n\r\ninterface Props {}\r\n\r\nexport interface User {\r\n  id: string;\r\n  avatarSrc: string;\r\n  email: string;\r\n  name: string;\r\n  link: string;\r\n  uri: string;\r\n}\r\n\r\ninterface BasicUser {\r\n  spotifyUri: string;\r\n  name: string;\r\n  avatarSrc: string;\r\n}\r\n\r\ninterface Context {\r\n  getAvailableDevices: () => Promise<SpotifyDevice[]>;\r\n  profile: User;\r\n}\r\n\r\nconst UserContext = createContext({} as any);\r\nconst spotifyUserEndpoint = `${SpotifyUtil.getApiUrl()}/me`;\r\n\r\nconst apiEndpoint = process.env.REACT_APP_API_HOST || \"https://localhost:44301/api\";\r\nconst userApiEndpoint = `${apiEndpoint}/user`;\r\n\r\nexport function UserProvider(props: Props) {\r\n  const { isAuthenticated, requestService } = useAuth();\r\n  const [profile, setProfile] = useState<User>({} as any);\r\n\r\n  async function load(): Promise<void> {\r\n    const { data } = await requestService.get<SpotifyUserGetResponse>(spotifyUserEndpoint);\r\n    const {\r\n      id,\r\n      email,\r\n      display_name: name,\r\n      external_urls: { spotify: link },\r\n      images,\r\n      uri,\r\n    } = data;\r\n    const avatarSrc = images[0]?.url;\r\n\r\n    setProfile({ id, email, name, link, avatarSrc, uri });\r\n\r\n    tryToSaveAtApi({ avatarSrc, spotifyUri: uri, name });\r\n  }\r\n\r\n  async function getAvailableDevices(): Promise<SpotifyDevice[]> {\r\n    const endpoint = `${spotifyUserEndpoint}/player/devices`;\r\n    const { data } = await requestService.get<SpotifyDevicesResponse>(endpoint);\r\n\r\n    return data.devices;\r\n  }\r\n\r\n  async function tryToSaveAtApi(basicUser: BasicUser): Promise<void> {\r\n    await requestService.post({\r\n      url: userApiEndpoint,\r\n      data: basicUser,\r\n    });\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (isAuthenticated) {\r\n      load();\r\n    } else {\r\n      setProfile({} as any);\r\n    } // eslint-disable-next-line\r\n  }, [isAuthenticated]);\r\n\r\n  return <UserContext.Provider value={{ getAvailableDevices, profile }} {...props} />;\r\n}\r\n\r\nexport const useUser = () => useContext<Context>(UserContext);\r\n","import { SpotifyImage } from \"../@types/spotify\";\r\nimport { CustomImage } from \"../@types/music\";\r\n\r\nexport class ImageMapper {\r\n  static toCustom(alt: string, images: SpotifyImage[]): CustomImage {\r\n    return {\r\n      alt,\r\n      src: images[0]?.url,\r\n    };\r\n  }\r\n}\r\n","import { ImageMapper } from \"./image\";\r\nimport { Music, Album } from \"../@types/music\";\r\nimport { SpotifyTracksSearchItem, SpotifyImage } from \"../@types/spotify\";\r\n\r\nexport class MusicMapper {\r\n  static toMusicTrack({ name, album, uri }: Spotify.Track): Music {\r\n    return {\r\n      id: uri,\r\n      image: ImageMapper.toCustom(name, album.images as SpotifyImage[]),\r\n      name,\r\n      album: {\r\n        id: album.uri,\r\n        name: album.name,\r\n        image: ImageMapper.toCustom(album.name, album.images as SpotifyImage[]),\r\n      },\r\n      uri,\r\n    };\r\n  }\r\n\r\n  static toMusic({ id, name, album, uri }: SpotifyTracksSearchItem): Music {\r\n    return {\r\n      id,\r\n      image: ImageMapper.toCustom(name, album.images),\r\n      name,\r\n      album: {\r\n        id: album.id,\r\n        name: album.name,\r\n        image: ImageMapper.toCustom(album.name, album.images),\r\n      },\r\n      uri,\r\n    };\r\n  }\r\n\r\n  static toAlbum({ id, name, images }: import(\"../@types/spotify\").SpotifyAlbum): Album {\r\n    return {\r\n      id,\r\n      name,\r\n      image: ImageMapper.toCustom(name, images),\r\n    };\r\n  }\r\n}\r\n","export class TimerUtil {\r\n  static debounce(callback: Function, wait: number): Function {\r\n    let timeout: NodeJS.Timeout | null;\r\n\r\n    return (...params: any[]): void => {\r\n      if (timeout != null) {\r\n        clearTimeout(timeout);\r\n      }\r\n\r\n      timeout = setTimeout((): void => {\r\n        timeout = null;\r\n        callback(...params);\r\n      }, wait);\r\n    };\r\n  }\r\n\r\n  static async wait(time: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(() => resolve(), time));\r\n  }\r\n}\r\n","import { EventType } from \"../contexts/event\";\r\n\r\nconst musicHistory: string[] = [];\r\n\r\nexport class PlayerUtil {\r\n  static stateToEvent(state: Spotify.PlaybackState): { type: EventType, value: string } {\r\n    const { current_track } = state?.track_window;\r\n    const lastMusic = musicHistory[musicHistory.length - 1]\r\n    const value = current_track.uri;\r\n    let type = EventType.PLAY_MUSIC\r\n\r\n    if (value == null)\r\n      throw new Error(\"Invalid current track\");\r\n\r\n    if (state.paused)\r\n      type = EventType.PAUSE_MUSIC\r\n    else if (lastMusic != null) {\r\n      if (lastMusic !== value)\r\n        type = EventType.CHANGE_MUSIC\r\n      else if (state?.position === 0)\r\n        type = EventType.RESTART_MUSIC\r\n    }\r\n\r\n    if (lastMusic !== value)\r\n      musicHistory.push(value)\r\n\r\n    return {\r\n      type,\r\n      value\r\n    }\r\n  }\r\n}\r\n","import React, { createContext, useContext, useEffect, useState } from \"react\";\r\n\r\nimport { useAuth } from \"./auth\";\r\nimport { SpotifyUtil, SpotifyPlayer } from \"../utils/spotify\";\r\nimport { Music } from \"../@types/music\";\r\nimport { MusicMapper } from \"../mappers/music\";\r\nimport { SpotifyPlayerResponse } from \"../@types/spotify\";\r\nimport { TimerUtil } from \"../utils/timer\";\r\nimport { PlayerUtil } from \"../utils/player\";\r\nimport { useEvents } from \"./event\";\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  isPlayerReady: boolean;\r\n  isPluginPlayerActive: boolean;\r\n  nextTrack: () => Promise<void>;\r\n  playingMusicInfo?: PlayingMusicInfo;\r\n  previousTrack: () => Promise<void>;\r\n  togglePlay: () => Promise<void>;\r\n  transferUserPlaybackToPlugin: () => Promise<void>;\r\n}\r\n\r\nexport interface PlayingMusicInfo {\r\n  position: number;\r\n  duration: number;\r\n  currentTrack: Music;\r\n  paused: boolean;\r\n}\r\n\r\nconst MusicContext = createContext<Context>({} as any);\r\nconst spotifyUserEndpoint = `${SpotifyUtil.getApiUrl()}/me`;\r\n\r\nconst debounce = TimerUtil.debounce((state: Spotify.PlaybackState, saveEvent: Function) => {\r\n  var { type, value } = PlayerUtil.stateToEvent(state);\r\n\r\n  saveEvent(type, value);\r\n}, 1000);\r\n\r\nexport function PlayerProvider(props: Props) {\r\n  const { accessToken, isAuthenticated, requestService } = useAuth();\r\n  const [player, setPlayer] = useState<SpotifyPlayer | null>(null);\r\n  const [isPluginPlayerActive, setIsPluginPlayerActive] = useState<any>(null);\r\n  const [isPlayerReady, setIsPlayerReady] = useState<any>(null);\r\n  const [playingMusicInfo, setPlayingMusicInfo] = useState<PlayingMusicInfo | undefined>();\r\n  const { save: saveEvent } = useEvents();\r\n\r\n  useEffect(() => {\r\n    if (isAuthenticated) {\r\n      createSpotifyPlayerIfNeedAndValidatePlayer();\r\n    } // eslint-disable-next-line\r\n  }, [accessToken, isAuthenticated]);\r\n\r\n  useEffect(() => {\r\n    setIsPlayerReady(player != null);\r\n\r\n    if (player != null) {\r\n      player.original.addListener(\"player_state_changed\", (state) => {\r\n        const {\r\n          position,\r\n          duration,\r\n          paused,\r\n          track_window: { current_track },\r\n        } = state;\r\n\r\n        debounce(state, saveEvent);\r\n        setPlayingMusicInfo({ currentTrack: MusicMapper.toMusicTrack(current_track), duration, position, paused });\r\n      });\r\n    } // eslint-disable-next-line\r\n  }, [player]);\r\n\r\n  async function createSpotifyPlayerIfNeed(): Promise<void> {\r\n    const player = await SpotifyUtil.createPlayer(accessToken);\r\n\r\n    setPlayer(player);\r\n  }\r\n\r\n  async function createSpotifyPlayerIfNeedAndValidatePlayer(): Promise<void> {\r\n    await createSpotifyPlayerIfNeed();\r\n    await loadCurrentPlayerInfo();\r\n  }\r\n\r\n  async function getCurrentPlayerInfo(): Promise<SpotifyPlayerResponse | null> {\r\n    const { data } = await requestService.get<SpotifyPlayerResponse | null>(`${spotifyUserEndpoint}/player`);\r\n\r\n    return data;\r\n  }\r\n\r\n  async function loadCurrentPlayerInfo(): Promise<void> {\r\n    const currentPlayer = await getCurrentPlayerInfo();\r\n\r\n    setIsPluginPlayerActive((currentPlayer?.device != null && player?.device_id) === currentPlayer?.device?.id);\r\n  }\r\n\r\n  async function nextTrack(): Promise<void> {\r\n    if (player == null) {\r\n      throw new Error(\"You have to login first!\");\r\n    }\r\n\r\n    await player.original.nextTrack();\r\n  }\r\n\r\n  async function previousTrack(): Promise<void> {\r\n    if (player == null) {\r\n      throw new Error(\"You have to login first!\");\r\n    }\r\n\r\n    await player.original.previousTrack();\r\n  }\r\n\r\n  async function togglePlay(): Promise<void> {\r\n    if (player == null) {\r\n      throw new Error(\"You have to login first!\");\r\n    }\r\n\r\n    await player.original.togglePlay();\r\n  }\r\n\r\n  async function transferUserPlaybackToPlugin(): Promise<void> {\r\n    const endpoint = `${spotifyUserEndpoint}/player`;\r\n\r\n    await requestService.put({\r\n      url: endpoint,\r\n      data: {\r\n        device_ids: [player?.device_id],\r\n      },\r\n    });\r\n    await TimerUtil.wait(500);\r\n    await loadCurrentPlayerInfo();\r\n  }\r\n\r\n  return (\r\n    <MusicContext.Provider\r\n      value={{\r\n        isPlayerReady,\r\n        isPluginPlayerActive,\r\n        nextTrack,\r\n        playingMusicInfo,\r\n        previousTrack,\r\n        togglePlay,\r\n        transferUserPlaybackToPlugin,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nexport const usePlayer = () => useContext<Context>(MusicContext);\r\n","import \"./style.scss\";\r\nimport React from \"react\";\r\n\r\nexport function Loader(): React.ReactElement {\r\n  return <div className=\"loader-component\">Loading...</div>;\r\n}\r\n","import { Artist } from \"../services/artist\";\r\nimport { SpotifyArtistsSearchItem, SpotifyTracksSearchItem } from \"../@types/spotify\";\r\nimport { MusicMapper } from \"./music\";\r\n\r\nexport class SearchMapper {\r\n  static toArtist({ uri, name, images }: SpotifyArtistsSearchItem): Artist {\r\n    return {\r\n      id: uri,\r\n      name,\r\n      image: {\r\n        alt: name,\r\n        src: images[0]?.url,\r\n      },\r\n    };\r\n  }\r\n\r\n  static toMusic(track: SpotifyTracksSearchItem): import(\"../@types/music\").Music {\r\n    return MusicMapper.toMusic(track);\r\n  }\r\n}\r\n","import React, { createContext, useContext } from \"react\";\r\n\r\nimport { Artist } from \"../services/artist\";\r\nimport { SearchMapper } from \"../mappers/search\";\r\nimport { SpotifySearchResponse } from \"../@types/spotify\";\r\nimport { SpotifyUtil } from \"../utils/spotify\";\r\nimport { useAuth } from \"./auth\";\r\nimport { Music } from \"../@types/music\";\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  searchArtists: (text: string) => Promise<Artist[]>;\r\n  searchMusic: (text: string) => Promise<Music[]>;\r\n}\r\n\r\nconst SearchContext = createContext({} as any);\r\nconst spotifySearchEndpoint = `${SpotifyUtil.getApiUrl()}/search`;\r\n\r\ntype SpotifySearchType = \"album\" | \"artist\" | \"playlist\" | \"track\" | \"show\" | \"episode\";\r\n\r\nexport function SearchProvider(props: Props) {\r\n  const { requestService } = useAuth();\r\n\r\n  async function search(text: string, type: SpotifySearchType): Promise<SpotifySearchResponse> {\r\n    const { data } = await requestService.get<SpotifySearchResponse>({\r\n      url: spotifySearchEndpoint,\r\n      params: { q: text, type },\r\n    });\r\n\r\n    return data;\r\n  }\r\n\r\n  async function searchArtists(text: string): Promise<Artist[]> {\r\n    const { artists } = await search(text, \"artist\");\r\n\r\n    if (!artists) {\r\n      throw new Error(\"Invalid response\");\r\n    }\r\n\r\n    return artists.items.map(SearchMapper.toArtist);\r\n  }\r\n\r\n  async function searchMusic(text: string): Promise<Music[]> {\r\n    const { tracks } = await search(text, \"track\");\r\n\r\n    if (!tracks) {\r\n      throw new Error(\"Invalid response\");\r\n    }\r\n\r\n    return tracks.items.map(SearchMapper.toMusic);\r\n  }\r\n\r\n  return <SearchContext.Provider value={{ searchArtists, searchMusic }} {...props} />;\r\n}\r\n\r\nexport const useSearch = () => useContext<Context>(SearchContext);\r\n","import React, { createContext, useContext } from \"react\";\r\nimport { requestService } from \"../services/request\";\r\nimport { StringUtil } from \"../utils/string\";\r\n\r\nexport interface Activity {\r\n  id: string;\r\n  name: string;\r\n  createdDate?: string;\r\n}\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  search: (text?: string) => Promise<Activity[]>;\r\n}\r\n\r\nconst USE_API = process.env.REACT_APP_USE_API_TO_LOAD_ACTIVITY === \"true\";\r\nconst apiEndpoint = process.env.REACT_APP_API_HOST || \"https://localhost:44301/api\";\r\nconst eventApiEndpoint = `${apiEndpoint}/activities`;\r\nconst baseHost = process.env.REACT_APP_HOST_URL || \"https://ericoloewe.github.io/computer-science-tcc\";\r\n\r\nconst ActivityContext = createContext({} as any);\r\n\r\nexport function ActivityProvider(props: Props) {\r\n  async function search(text?: string): Promise<Activity[]> {\r\n    return USE_API ? searchFromApi(text) : searchFromJson(text);\r\n  }\r\n\r\n  async function searchFromJson(text?: string): Promise<Activity[]> {\r\n    const { data } = await requestService.get<string[]>(`${baseHost}/activities.json`);\r\n\r\n    return data\r\n      .filter((l) => !text || l.toLowerCase().includes(text?.toLowerCase()))\r\n      .map((l) => ({\r\n        id: StringUtil.toKebabCase(l),\r\n        name: l,\r\n      }));\r\n  }\r\n\r\n  async function searchFromApi(text?: string): Promise<Activity[]> {\r\n    const { data } = await requestService.get<Activity[]>({\r\n      url: eventApiEndpoint,\r\n      params: { text },\r\n    });\r\n\r\n    return data;\r\n  }\r\n\r\n  return <ActivityContext.Provider value={{ search }} {...props} />;\r\n}\r\n\r\nexport const useActivity = () => useContext<Context>(ActivityContext);\r\n","import React, { createContext, useContext } from \"react\";\r\nimport { requestService } from \"../services/request\";\r\nimport { StringUtil } from \"../utils/string\";\r\n\r\nexport interface Feeling {\r\n  id: string;\r\n  name: string;\r\n  createdDate?: string;\r\n}\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  search: (text?: string) => Promise<Feeling[]>;\r\n}\r\n\r\nconst USE_API = process.env.REACT_APP_USE_API_TO_LOAD_FEELINGS === \"true\";\r\nconst apiEndpoint = process.env.REACT_APP_API_HOST || \"https://localhost:44301/api\";\r\nconst eventApiEndpoint = `${apiEndpoint}/feelings`;\r\nconst baseHost = process.env.REACT_APP_HOST_URL || \"https://ericoloewe.github.io/computer-science-tcc\";\r\n\r\nconst FeelingContext = createContext({} as any);\r\n\r\nexport function FeelingProvider(props: Props) {\r\n  async function search(text?: string): Promise<Feeling[]> {\r\n    return USE_API ? searchFromApi(text) : searchFromJson(text);\r\n  }\r\n\r\n  async function searchFromJson(text?: string): Promise<Feeling[]> {\r\n    const { data } = await requestService.get<string[]>(`${baseHost}/feelings.json`);\r\n\r\n    return data\r\n      .filter((l) => !text || l.toLowerCase().includes(text?.toLowerCase()))\r\n      .map((l) => ({\r\n        id: StringUtil.toKebabCase(l),\r\n        name: l,\r\n      }));\r\n  }\r\n\r\n  async function searchFromApi(text?: string): Promise<Feeling[]> {\r\n    const { data } = await requestService.get<Feeling[]>({\r\n      url: eventApiEndpoint,\r\n      params: { text },\r\n    });\r\n\r\n    return data;\r\n  }\r\n\r\n  return <FeelingContext.Provider value={{ search }} {...props} />;\r\n}\r\n\r\nexport const useFeeling = () => useContext<Context>(FeelingContext);\r\n","import React, { createContext, useContext } from \"react\";\r\nimport { requestService } from \"../services/request\";\r\nimport { StringUtil } from \"../utils/string\";\r\n\r\nexport interface Location {\r\n  id: string;\r\n  name: string;\r\n  createdDate?: string;\r\n}\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  search: (text?: string) => Promise<Location[]>;\r\n}\r\n\r\nconst apiEndpoint = process.env.REACT_APP_API_HOST || \"https://localhost:44301/api\";\r\nconst eventApiEndpoint = `${apiEndpoint}/locations`;\r\nconst USE_API = process.env.REACT_APP_USE_API_TO_LOAD_LOCATION === \"true\";\r\nconst baseHost = process.env.REACT_APP_HOST_URL || \"https://ericoloewe.github.io/computer-science-tcc\";\r\n\r\nconst LocationContext = createContext({} as any);\r\n\r\nexport function LocationProvider(props: Props) {\r\n  async function search(text?: string): Promise<Location[]> {\r\n    return USE_API ? searchFromApi(text) : searchFromJson(text);\r\n  }\r\n\r\n  async function searchFromJson(text?: string): Promise<Location[]> {\r\n    const { data } = await requestService.get<string[]>(`${baseHost}/locations.json`);\r\n\r\n    return data\r\n      .filter((l) => !text || l.toLowerCase().includes(text?.toLowerCase()))\r\n      .map((l) => ({\r\n        id: StringUtil.toKebabCase(l),\r\n        name: l,\r\n      }));\r\n  }\r\n\r\n  async function searchFromApi(text?: string): Promise<Location[]> {\r\n    const { data } = await requestService.get<Location[]>({\r\n      url: eventApiEndpoint,\r\n      params: { text },\r\n    });\r\n\r\n    return data;\r\n  }\r\n\r\n  return <LocationContext.Provider value={{ search }} {...props} />;\r\n}\r\n\r\nexport const useLocation = () => useContext<Context>(LocationContext);\r\n","import axios, { AxiosResponse } from \"axios\";\r\nimport { StringUtil } from \"../utils/string\";\r\n\r\nexport interface GetRequest {\r\n  url: string;\r\n  headers?: object;\r\n  params?: object;\r\n}\r\n\r\nexport interface PostRequest {\r\n  url: string;\r\n  headers?: object;\r\n  data?: object;\r\n}\r\n\r\nexport interface Response<T> {\r\n  headers?: object;\r\n  data: T;\r\n  status: number;\r\n}\r\n\r\ntype Request = GetRequest | PostRequest;\r\n\r\nclass RequestService {\r\n  async get<T>(getRequest: string | GetRequest): Promise<Response<T>> {\r\n    let request: GetRequest = this.parseRequest(getRequest);\r\n    const response = await axios(request);\r\n\r\n    return this.mapAxiosToResponse(response);\r\n  }\r\n\r\n  async post<T>(postRequest: string | PostRequest): Promise<Response<T>> {\r\n    let request: PostRequest = this.parseRequest(postRequest);\r\n    const response = await axios({ ...request, method: \"post\" });\r\n\r\n    return this.mapAxiosToResponse(response);\r\n  }\r\n\r\n  async put<T>(putRequest: string | PostRequest): Promise<Response<T>> {\r\n    let request: PostRequest = this.parseRequest(putRequest);\r\n    const response = await axios({ ...request, method: \"put\" });\r\n\r\n    return this.mapAxiosToResponse(response);\r\n  }\r\n\r\n  protected parseRequest(getRequest: string | Request): Request {\r\n    let request: Request = getRequest as Request;\r\n\r\n    if (StringUtil.isString(getRequest)) {\r\n      request = { url: getRequest as string };\r\n    }\r\n\r\n    return request;\r\n  }\r\n\r\n  private mapAxiosToResponse<T>(response: AxiosResponse): Response<T> {\r\n    const { data, headers, status } = response;\r\n\r\n    return {\r\n      data,\r\n      headers,\r\n      status,\r\n    };\r\n  }\r\n}\r\n\r\nexport class SpotifyRequestService extends RequestService {\r\n  accessToken: string | null;\r\n\r\n  constructor(accessToken: string | null) {\r\n    super();\r\n    this.accessToken = accessToken;\r\n  }\r\n\r\n  protected parseRequest(getRequest: string | Request): Request {\r\n    const request = super.parseRequest(getRequest);\r\n\r\n    if (this.accessToken == null) {\r\n      throw new Error(\"No access token, you must login!\");\r\n    }\r\n\r\n    request.headers = {\r\n      Authorization: `Bearer ${this.accessToken}`,\r\n    };\r\n\r\n    return request;\r\n  }\r\n}\r\n\r\nexport const requestService = new RequestService();\r\n","export class StringUtil {\r\n  static isEmpty<T>(any: T): boolean {\r\n    return any == null || (typeof any === \"string\" && any.trim().length === 0);\r\n  }\r\n\r\n  static isString<T>(any: T): boolean {\r\n    return typeof any === \"string\";\r\n  }\r\n\r\n  static sliceIfNeed(str: string, size: number = 50): string {\r\n    return str.length > size ? `${str.slice(0, size)}...` : str;\r\n  }\r\n\r\n  static toKebabCase(str: string): string {\r\n    return str\r\n      .normalize('NFD')\r\n      .replace(/[\\u0300-\\u036f]/g, '')\r\n      .replace(/[^-\\w ]/g, '')\r\n      .replace(/-+/g, ' ')\r\n      .trim()\r\n      .replace(/ +/g, '-')\r\n      .toLowerCase()\r\n  }\r\n\r\n  static toString(str: any): string {\r\n    if (!str) {\r\n      throw new Error(\"Invalid str\");\r\n    }\r\n\r\n    return str.toString();\r\n  }\r\n\r\n  static toStringOrDefault(str: any, def: string): string {\r\n    return !str ? def : str.toString();\r\n  }\r\n}\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\nimport { useAuth } from \"../../contexts/auth\";\r\nimport { Route, Redirect } from \"react-router-dom\";\r\n\r\nexport function PrivateRoute({ children, ...rest }: any) {\r\n  const { isAuthenticated } = useAuth();\r\n\r\n  return (\r\n    <Route\r\n      {...rest}\r\n      render={({ location }) =>\r\n        isAuthenticated ? (\r\n          children\r\n        ) : (\r\n          <Redirect\r\n            to={{\r\n              pathname: \"/welcome\",\r\n              state: { from: location },\r\n            }}\r\n          />\r\n        )\r\n      }\r\n    />\r\n  );\r\n}\r\n\r\nexport function NonAuthRoute({ children, ...rest }: any) {\r\n  const { isAuthenticated } = useAuth();\r\n\r\n  return (\r\n    <Route\r\n      {...rest}\r\n      render={({ location }) =>\r\n        !isAuthenticated ? (\r\n          children\r\n        ) : (\r\n          <Redirect\r\n            to={{\r\n              pathname: \"/\",\r\n              state: { from: location },\r\n            }}\r\n          />\r\n        )\r\n      }\r\n    />\r\n  );\r\n}\r\n","import { BasicPlaylist, Playlist } from \"../@types/playlist\";\r\nimport { PlaylistItem } from \"../@types/spotify\";\r\nimport { StringUtil } from \"../utils/string\";\r\nimport { MusicMapper } from \"./music\";\r\n\r\nexport class PlaylistMapper {\r\n  static toPlaylist({\r\n    id,\r\n    name,\r\n    description,\r\n    images,\r\n    tracks,\r\n  }: import(\"../@types/spotify\").SpotifyLoadPlaylistResponse): Playlist {\r\n    return {\r\n      id,\r\n      title: name,\r\n      description: StringUtil.sliceIfNeed(description),\r\n      image: {\r\n        alt: name,\r\n        src: images[0]?.url,\r\n      },\r\n      musics: tracks.items.map((t) => MusicMapper.toMusic(t.track)),\r\n    };\r\n  }\r\n\r\n  static toBasicPlaylist({ id, name, images, description }: PlaylistItem): BasicPlaylist {\r\n    return {\r\n      id,\r\n      title: name,\r\n      description: StringUtil.sliceIfNeed(description),\r\n      image: {\r\n        alt: name,\r\n        src: images[0]?.url,\r\n      },\r\n    };\r\n  }\r\n}\r\n","import React, { createContext, useContext } from \"react\";\r\nimport { useAuth } from \"./auth\";\r\n\r\nimport { SpotifyUtil } from \"../utils/spotify\";\r\nimport { PlaylistMapper } from \"../mappers/playlist\";\r\nimport { BasicPlaylist, Playlist } from \"../@types/playlist\";\r\nimport { SpotifyLoadPlaylistResponse, SpotifyLoadUserPlaylistsResponse } from \"../@types/spotify\";\r\nimport { useUser } from \"./user\";\r\n\r\ninterface Props {}\r\n\r\ninterface Context {\r\n  addMusics: (playlistId: string, musicsIds: string[]) => Promise<void>;\r\n  create: () => Promise<string>;\r\n  loadAll: () => Promise<BasicPlaylist[]>;\r\n  load: (id: string) => Promise<Playlist>;\r\n  rename: (playlistId: string, newName: string) => Promise<void>;\r\n}\r\n\r\nconst PlaylistContext = createContext({} as any);\r\nconst spotifyPlaylistsEndpoint = `${SpotifyUtil.getApiUrl()}/me/playlists`;\r\nconst spotifyLoadPlaylistEndpoint = `${SpotifyUtil.getApiUrl()}/playlists`;\r\n\r\nexport function PlaylistProvider(props: Props) {\r\n  const {\r\n    profile: { id },\r\n  } = useUser();\r\n  const { requestService } = useAuth();\r\n\r\n  async function addMusics(playlistId: string, musicsIds: string[]): Promise<void> {\r\n    await requestService.post({\r\n      url: `${spotifyLoadPlaylistEndpoint}/${playlistId}/tracks`,\r\n      data: {\r\n        uris: musicsIds,\r\n      },\r\n    });\r\n  }\r\n\r\n  async function create(): Promise<string> {\r\n    const { data } = await requestService.post<SpotifyLoadPlaylistResponse>({\r\n      url: `${SpotifyUtil.getApiUrl()}/users/${id}/playlists`,\r\n      data: {\r\n        name: \"Nova playlist\",\r\n      },\r\n    });\r\n\r\n    return data.id;\r\n  }\r\n\r\n  async function loadAll(): Promise<BasicPlaylist[]> {\r\n    const { data } = await requestService.get<SpotifyLoadUserPlaylistsResponse>({\r\n      url: spotifyPlaylistsEndpoint,\r\n    });\r\n\r\n    return data.items.map(PlaylistMapper.toBasicPlaylist);\r\n  }\r\n\r\n  async function load(id: string): Promise<Playlist> {\r\n    const { data } = await requestService.get<SpotifyLoadPlaylistResponse>({\r\n      url: `${spotifyLoadPlaylistEndpoint}/${id}`,\r\n    });\r\n\r\n    return PlaylistMapper.toPlaylist(data);\r\n  }\r\n\r\n  async function rename(playlistId: string, newName: string): Promise<void> {\r\n    await requestService.put({\r\n      url: `${spotifyLoadPlaylistEndpoint}/${playlistId}`,\r\n      data: {\r\n        name: newName,\r\n      },\r\n    });\r\n  }\r\n\r\n  return <PlaylistContext.Provider value={{ addMusics, create, load, loadAll, rename }} {...props} />;\r\n}\r\n\r\nexport const usePlaylist = () => useContext<Context>(PlaylistContext);\r\n","import React from \"react\";\r\n\r\nimport { ActivityProvider } from \"./activity\";\r\nimport { AuthProvider } from \"./auth\";\r\nimport { EventsProvider } from \"./event\";\r\nimport { FeelingProvider } from \"./feeling\";\r\nimport { LocationProvider } from \"./location\";\r\nimport { PlayerProvider } from \"./player\";\r\nimport { PlaylistProvider } from \"./playlist\";\r\nimport { SearchProvider } from \"./search\";\r\nimport { UserProvider } from \"./user\";\r\n\r\ninterface Props {\r\n  children: JSX.Element;\r\n}\r\n\r\nexport function AppProviders({ children }: Props) {\r\n  return (\r\n    <AuthProvider>\r\n      <UserProvider>\r\n        <EventsProvider>\r\n          <PlaylistProvider>\r\n            <PlayerProvider>\r\n              <FeelingProvider>\r\n                <ActivityProvider>\r\n                  <LocationProvider>\r\n                    <SearchProvider>{children}</SearchProvider>\r\n                  </LocationProvider>\r\n                </ActivityProvider>\r\n              </FeelingProvider>\r\n            </PlayerProvider>\r\n          </PlaylistProvider>\r\n        </EventsProvider>\r\n      </UserProvider>\r\n    </AuthProvider>\r\n  );\r\n}\r\n","import React, { Suspense, StrictMode } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.scss\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\nimport { HashRouter, Switch } from \"react-router-dom\";\r\nimport { Loader } from \"./components/loader\";\r\nimport { PrivateRoute, NonAuthRoute } from \"./components/router\";\r\nimport { AppProviders } from \"./contexts\";\r\n\r\nconst Home = React.lazy(() => import(\"./pages/home\"));\r\nconst Welcome = React.lazy(() => import(\"./pages/welcome\"));\r\nconst Login = React.lazy(() => import(\"./pages/login\"));\r\nconst LoginRedirectSpotify = React.lazy(() => import(\"./pages/login-redirect-spotify\"));\r\nconst Logout = React.lazy(() => import(\"./pages/logout\"));\r\nconst Artists = React.lazy(() => import(\"./pages/artists\"));\r\nconst Gender = React.lazy(() => import(\"./pages/genre\"));\r\nconst Feeling = React.lazy(() => import(\"./pages/feeling\"));\r\nconst Activity = React.lazy(() => import(\"./pages/activity\"));\r\nconst Location = React.lazy(() => import(\"./pages/location\"));\r\nconst MusicSearch = React.lazy(() => import(\"./pages/music-search\"));\r\n\r\nReactDOM.render(\r\n  <StrictMode>\r\n    <Suspense fallback={<Loader />}>\r\n      <AppProviders>\r\n        <HashRouter>\r\n          <Switch>\r\n            <PrivateRoute path=\"/new-context/activity\">\r\n              <Activity />\r\n            </PrivateRoute>\r\n            <PrivateRoute path=\"/new-context/feeling\">\r\n              <Feeling />\r\n            </PrivateRoute>\r\n            <PrivateRoute path=\"/new-context/music-search\">\r\n              <MusicSearch />\r\n            </PrivateRoute>\r\n            <PrivateRoute path=\"/new-context/gender\">\r\n              <Gender />\r\n            </PrivateRoute>\r\n            <PrivateRoute path=\"/new-context/artists\">\r\n              <Artists />\r\n            </PrivateRoute>\r\n            <PrivateRoute path=\"/new-context/location\">\r\n              <Location />\r\n            </PrivateRoute>\r\n            <NonAuthRoute path=\"/login\">\r\n              <Login />\r\n            </NonAuthRoute>\r\n            <NonAuthRoute path=\"/login-redirect-spotify\">\r\n              <LoginRedirectSpotify />\r\n            </NonAuthRoute>\r\n            <NonAuthRoute exact path=\"/:access_token(access_token=.*)\">\r\n              <LoginRedirectSpotify />\r\n            </NonAuthRoute>\r\n            <PrivateRoute path=\"/logout\">\r\n              <Logout />\r\n            </PrivateRoute>\r\n            <NonAuthRoute path=\"/welcome\">\r\n              <Welcome />\r\n            </NonAuthRoute>\r\n            <PrivateRoute path=\"/\">\r\n              <Home />\r\n            </PrivateRoute>\r\n          </Switch>\r\n        </HashRouter>\r\n      </AppProviders>\r\n    </Suspense>\r\n  </StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","class CookieService {\r\n  delete(key: string): void {\r\n    document.cookie = key + \"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;\";\r\n  }\r\n\r\n  get(key: string): string {\r\n    const { cookie } = document;\r\n\r\n    let value = \"\";\r\n\r\n    if (cookie.includes(key)) {\r\n      const start = cookie.indexOf(key);\r\n\r\n      value = cookie.substring(start).split(\";\", 1)[0].split(\"=\")[1];\r\n    }\r\n\r\n    return decodeURIComponent(value);\r\n  }\r\n\r\n  save(key: string, value: string, expiresInSeconds?: number): void {\r\n    let expires = \"\";\r\n\r\n    if (!!expiresInSeconds) {\r\n      const date = new Date();\r\n      date.setTime(date.getTime() + expiresInSeconds * 1000);\r\n      expires = \"; expires=\" + date.toUTCString();\r\n    }\r\n\r\n    document.cookie = `${key}=${value}${expires}; path=/`;\r\n  }\r\n}\r\n\r\nexport const cookieService = new CookieService();\r\n","import React, { createContext, useState, useEffect } from \"react\";\r\n\r\nimport { cookieService } from \"../services/storage\";\r\nimport { SpotifyUtil } from \"../utils/spotify\";\r\nimport { StringUtil } from \"../utils/string\";\r\nimport { SpotifyRequestService } from \"../services/request\";\r\n\r\ninterface Props {}\r\ninterface Context {\r\n  accessToken: string;\r\n  isAuthenticated: boolean;\r\n  logout: () => void;\r\n  requestService: SpotifyRequestService;\r\n  saveToken: (redirectUrl: string) => void;\r\n}\r\n\r\nconst COOKIE_NAME = process.env.REACT_APP_COOKIE_NAME || \"SpotifyToken\";\r\nconst AuthContext = createContext({ isAuthenticated: false } as any);\r\n\r\nexport function AuthProvider(props: Props) {\r\n  const [accessToken, setAccessToken] = useState<null | string>(cookieService.get(COOKIE_NAME));\r\n  const [requestService, setRequestService] = useState(new SpotifyRequestService(accessToken));\r\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\r\n\r\n  function logout(): void {\r\n    setAccessToken(null);\r\n    cookieService.delete(COOKIE_NAME);\r\n  }\r\n\r\n  function saveToken(redirectUrl: string): void {\r\n    const { accessToken: newAccessToken, expiresInSeconds } = SpotifyUtil.getTokenAndInfoFromRedirectUrl(redirectUrl);\r\n\r\n    cookieService.save(COOKIE_NAME, newAccessToken, expiresInSeconds);\r\n    setAccessToken(newAccessToken);\r\n  }\r\n\r\n  useEffect(() => {\r\n    setIsAuthenticated(!StringUtil.isEmpty(accessToken));\r\n    setRequestService(new SpotifyRequestService(accessToken));\r\n  }, [accessToken]);\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ logout, saveToken, isAuthenticated, accessToken, requestService }} {...props} />\r\n  );\r\n}\r\n\r\nexport const useAuth = () => React.useContext<Context>(AuthContext);\r\n"],"sourceRoot":""}